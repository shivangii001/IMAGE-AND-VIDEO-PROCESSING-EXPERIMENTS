# -*- coding: utf-8 -*-
"""Experiment_5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bLle-0I_9C17HN6vxYkEz1aGkBuNrlDu
"""

import math
import cv2
import numpy as np
import matplotlib.pyplot as plt

def fft(x, invert):
    N = len(x)
    # base case
    if N == 1:
        return x

    # split into even and odd parts and recursively compute their FFT
    X_even = fft(x[::2], invert)
    X_odd = fft(x[1::2], invert)

    # define DFT coefficient
    ang = 2 * math.pi / N * (-1 if invert else 1)
    w = 1 + 0j
    wn = math.cos(ang) + 1j * math.sin(ang)
    X = [(0 + 0j) for _ in range(N)]

    # merge the even and odd parts to get the solution for the current subproblem
    for i in range(0, int(N/2)):
        X[i] = X_even[i] + w * X_odd[i]
        X[i + int(N/2)] = X_even[i] - w * X_odd[i]
        if invert:
            X[i] /= 2
            X[i + int(N/2)] /= 2
        w *= wn

    return X

def fftshift_image(img):
    rows, cols = len(img), len(img[0])
    new_img = [[0 for _ in range(cols)] for __ in range(rows)]
    for i in range(rows):
        for j in range(int(cols/2)):
            new_img[i][j] = img[i][j+int(cols/2)]
            new_img[i][j+int(cols/2)] = img[i][j]

    for j in range(cols):
        for i in range(int(rows/2)):
            tmp = new_img[i][j]
            new_img[i][j] = new_img[i+int(rows/2)][j]
            new_img[i+int(rows/2)][j] = tmp
    return new_img

def pad_image(img):
    rows, cols = len(img), len(img[0])
    new_rows, new_cols = 1, 1

    # Get the nearest higher power of 2 for row and column size
    while new_rows < rows:
        new_rows *= 2
    while new_cols < cols:
        new_cols *= 2

    new_img = [[0 for _ in range(new_cols)] for __ in range(new_rows)]

    for i in range(rows):
        for j in range(cols):
            new_img[i][j] = img[i][j]
    return new_img

def unpad(img, orig_rows, orig_cols):
    # Crop the image to its original dimension
    new_img = [[img[i][j] for j in range(orig_cols)] for i in range(orig_rows)]
    return new_img

def fft_image(img, invert):
    orig_rows, orig_cols = len(img), len(img[0])
    rows, cols = len(img), len(img[0])
    IMG = [[img[i][j] for j in range(cols)] for i in range(rows)]

    if invert:
        IMG = fftshift_image(IMG)

    # Apply FFT along columns
    for col in range(cols):
        cur = [IMG[row][col] for row in range(rows)]
        cur = fft(cur, invert)
        for row in range(rows):
            IMG[row][col] = cur[row]

    # Apply FFT along rows
    for row in range(rows):
        cur = [IMG[row][col] for col in range(cols)]
        cur = fft(cur, invert)
        for col in range(cols):
            IMG[row][col] = cur[col]

    if not invert:
        IMG = fftshift_image(IMG)
    return IMG

def ideal_filter(f0, type, rows, cols):
    filter = [[0 for _ in range(cols)] for __ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            d = math.sqrt(pow(i - int(rows/2), 2) + pow(j - int(cols/2), 2))
            if type == 'low':
                if d < f0:
                    filter[i][j] = 1
            elif type == 'high':
                if d > f0:
                    filter[i][j] = 1
    return filter

def butterworth_filter(f0, type, rows, cols, order):
    filter = [[0 for _ in range(cols)] for __ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            d = math.sqrt(pow(i - int(rows/2), 2) + pow(j - int(cols/2), 2)) + 1e-30
            if type == 'low':
                filter[i][j] = 1 / (1 +  pow(d / f0, 2 * order))
            elif type == 'high':
                filter[i][j] = 1 / (1 + pow(f0 / d, 2 * order))
    return filter

def gaussian_filter(f0, type, rows, cols):
    filter = [[0 for _ in range(cols)] for __ in range(rows)]
    sigma = f0 / (math.sqrt(math.log(2)))
    for i in range(rows):
        for j in range(cols):
            d = math.sqrt(pow(i - int(rows/2), 2) + pow(j - int(cols/2), 2)) + 1e-30
            if type == 'low':
                filter[i][j] = math.exp(-1 / (2 * sigma * sigma) * d * d)
            elif type == 'high':
                 filter[i][j] = 1 - math.exp(-1 / (2 * sigma * sigma) * d * d)

    return filter

def apply_filter(img, filter):
    rows, cols = len(img), len(img[0])
    new_img = [[img[i][j] for j in range(cols)] for i in range(rows)]

    # Multiply elementwise to apply the filter in the frequency domain
    for i in range(rows):
        for j in range(cols):
            new_img[i][j] *= filter[i][j]
    return new_img

def read_image(file):
    img = cv2.imread(file, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print("Error: Could not open or read the image.")
        return None, None, None

    # Convert returned numpy array to list
    img = [[complex(img[i][j]) for j in range(len(img[0]))] for i in range(len(img))]
    orig_rows, orig_cols = len(img), len(img[0])

    # Pad the image to the nearest higher power of 2 for FFT
    img = pad_image(img)
    return img, orig_rows, orig_cols

def write_image(file, img, orig_rows, orig_cols):
    # Remove added padding from the image
    img = unpad(img, orig_rows, orig_cols)

    # Scale pixels so as to lie from 0 to 255
    max_val = 0
    min_val = 1e30
    rows, cols = len(img), len(img[0])
    for i in range(rows):
        for j in range(cols):
            max_val = max(max_val, abs(img[i][j]))
            min_val = min(min_val, abs(img[i][j]))
    scale = 255 / math.log(1 + max_val)
    for i in range(rows):
        for j in range(cols):
            img[i][j] = scale * math.log(1 + abs(img[i][j]))

    # Convert list to numpy array
    img = np.array(img)
    img = img.astype(np.uint8)

    # Save the image
    cv2.imwrite(file, img)
    print(f"Image saved as {file}")

def q1(file, cutoff_frequency):
    # Implements Question 1
    img, orig_rows, orig_cols = read_image(file)
    rows, cols = len(img), len(img[0])

    IMG = fft_image(img, False)

    filter_type = input("Input filter (ideal, gaussian, butterworth): ")
    filter_type = filter_type.lower()

    if filter_type == 'ideal':
        filter = ideal_filter(cutoff_frequency, 'high', rows, cols)
    elif filter_type == 'gaussian':
        filter = gaussian_filter(cutoff_frequency, 'high', rows, cols)
    elif filter_type == 'butterworth':
        order = int(input("Enter order: "))
        filter = butterworth_filter(cutoff_frequency, 'low', rows, cols, order)
    else:
        print("Invalid input")
        return

    IMG = apply_filter(IMG, filter)

    log_mag_spectrum = [[20 * math.log10(1 + abs(IMG[i][j])) for j in range(cols)] for i in range(rows)]
    write_image("filtered_spectrum.jpg", log_mag_spectrum, orig_rows, orig_cols)

    img_filtered = fft_image(IMG, True)
    img_filtered = [[abs(img_filtered[i][j]) for j in range(cols)] for i in range(rows)]
    write_image("filtered_image.jpg", img_filtered, orig_rows, orig_cols)

def q2(file1, file2):
    # Implements Question 2
    img1, orig_rows, orig_cols = read_image(file1)
    img2, _, __ = read_image(file2)

    IMG1 = fft_image(img1, False)
    filter1 = np.array(gaussian_filter(25, 'low', len(img1), len(img1[0]))).astype(np.complex64)
    IMG1 = apply_filter(IMG1, filter1)

    IMG2 = fft_image(img2, False)
    filter2 = np.array(gaussian_filter(20, 'high', len(img2), len(img2[0]))).astype(np.complex64)
    IMG2 = apply_filter(IMG2, filter2)

    IMG = [[0 for _ in range(len(IMG1[0]))] for __ in range(len(IMG1))]
    max_val = 0
    for i in range(len(IMG)):
        for j in range(len(IMG[0])):
            IMG[i][j] = IMG1[i][j] + IMG2[i][j]
            # max_val = max(max_val, abs(IMG[i][j]))

    img = fft_image(IMG, True)
    img = [[abs(img[i][j]) for j in range(len(img[0]))] for i in range(len(img))]
    write_image("hybrid.jpg", img, orig_rows, orig_cols)

def q3(file, cutoff_frequency):
    # Implements Question 3
    img, orig_rows, orig_cols = read_image(file)
    rows, cols = len(img), len(img[0])

    IMG = fft_image(img, False)
    log_mag_spectrum = [[20 * math.log10(1 + abs(IMG[i][j])) for j in range(cols)] for i in range(rows)]
    write_image("original_spectrum.jpg", log_mag_spectrum, orig_rows, orig_cols)

    MED = [[0 for _ in range(cols)] for i in range(rows)]
    r = 2
    th = 10

    for i in range(rows):
        for j in range(cols):
            vals = []
            for k in range(-r, r + 1):
                for l in range(-r, r + 1):
                    if (i + k >= 0) and (i + k < rows) and (j + l >= 0) and (j + l < cols):
                        vals.append(IMG[i + k][j + l])
            vals.sort(key=abs)
            MED[i][j] = vals[int(len(vals) / 2)]

    for i in range(rows):
        for j in range(cols):
            if abs(i - int(rows / 2)) <= r and abs(j - int(cols / 2)) <= r:
                continue
            if abs(IMG[i][j]) / abs(MED[i][j]) > th:
                IMG[i][j] = MED[i][j]

    log_mag_spectrum = [[20 * math.log10(1 + abs(IMG[i][j])) for j in range(cols)] for i in range(rows)]
    write_image("filtered_spectrum.jpg", log_mag_spectrum, orig_rows, orig_cols)

    denoise_img = fft_image(IMG, True)
    denoise_img = [[abs(denoise_img[i][j]) for j in range(cols)] for i in range(rows)]
    write_image("denoise.jpg", denoise_img, orig_rows, orig_cols)

def main():
    while True:
        print("Choose an option:")
        print("1. Question 1 - Frequency Domain Filtering")
        print("2. Question 2 - Hybrid Image")
        print("3. Question 3 - Noise Removal")


        option = int(input("Enter your choice: "))

        if option == 1:
            file = input("Enter image filename: ")
            cutoff_frequency = float(input("Enter cutoff frequency: "))
            q1(file, cutoff_frequency)
            break

        elif option == 2:
            file1 = "einstein.png"
            file2 = "marilyn.png"
            q2(file1, file2)
            break

        elif option == 3:
            file = input("Enter image filename: ")
            cutoff_frequency = float(input("Enter cutoff frequency: "))
            q3(file, cutoff_frequency)
            break

        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()