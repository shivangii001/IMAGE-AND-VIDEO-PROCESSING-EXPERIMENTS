# -*- coding: utf-8 -*-
"""Exp-01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sg3cBuwxn0BrkpUaSxrgKu7CU-8dPj2I

#READ
"""

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

def read_bmp_header(file_path):
    with open(file_path, "rb") as file:
        # Read BMP file header (size: 54 bytes)

        header_data = file.read(54)

        # Extract header values
        signature = header_data[0:2]  # BMP signature (should be 'BM')
        if signature != b'BM':
            print("Error: Not a BMP image")
            return None

        file_size = int.from_bytes(header_data[2:6], byteorder="little")
        offset = int.from_bytes(header_data[10:14], byteorder="little")
        width = int.from_bytes(header_data[18:22], byteorder="little")
        height = int.from_bytes(header_data[22:26], byteorder="little")
        bit_depth = int.from_bytes(header_data[28:30], byteorder="little")
        color_planes = int.from_bytes(header_data[26:28], byteorder="little")
        dib_header_size = int.from_bytes(header_data[14:18], byteorder="little")
        num_colors = int.from_bytes(header_data[46:50], byteorder="little")

        # Calculate raw image size in bytes based on bit depth
        bytes_per_pixel = bit_depth // 8
        raw_image_size_bytes = width * height * bytes_per_pixel

        # Print header information
        print("BMP Signature:", signature.decode("utf-8"))
        print("File Size:", file_size, "bytes")
        print("Offset:", offset, "bytes")
        print("Width:", width, "pixels")
        print("Height:", height, "pixels")
        print("Bit Depth:", bit_depth, "bits per pixel")
        print("Color Planes:", color_planes)
        print("DIB Header Size:", dib_header_size, "bytes")
        print("Raw Image Size:", raw_image_size_bytes, "bytes")
        print("Number of Colors:", num_colors)

        return {
            "signature": signature.decode("utf-8"),
            "file_size": file_size,
            "offset": offset,
            "width": width,
            "height": height,
            "bit_depth": bit_depth,
            "color_planes": color_planes,
            "dib_header_size": dib_header_size,
            "raw_image_size_bytes": raw_image_size_bytes,
            "num_colors": num_colors
        }

def display_img(file_path):
    # Load the BMP image using matplotlib's imread function
    bmp_image = mpimg.imread(file_path)

    # Check if the image has a color palette
    if bmp_image.ndim == 2:
        # Grayscale image
        plt.imshow(bmp_image, cmap='gray', vmin=0, vmax=255)
    else:
        # RGB image
        plt.imshow(bmp_image)

    plt.axis('off')  # Turn off axis labels and ticks
    plt.show()


file_path = input("Enter path of file to be read (*.bmp): ")
header_info = read_bmp_header(file_path)
if header_info is not None:
    display_img(file_path)

"""#WRITE"""

with open(file_path,'rb') as file:
  image_data=file.read()
  offset = int.from_bytes(image_data[10:14], byteorder="little")
  pixel_data_offset=offset
  pixel_data_length=len(image_data)-pixel_data_offset
  pixel_data=image_data[pixel_data_offset:]

def write_bmp_img(file_path,image_data,pixel_data):
  bmp_image=image_data+pixel_data
  with open(file_path,'wb') as file:
    file.write(bmp_image)

output_file_path=input("Enter path of file with which you want to save (*.bmp): ")
write_bmp_img(output_file_path,image_data,pixel_data)
display_img(output_file_path)

"""#CHANNEL MANIPULATION"""

def color_channel_manipulation(image_data, file_name):
    offset = int.from_bytes(image_data[10:14], "little")
    bpp = int.from_bytes(image_data[28:30], "little")
    mylist = bytearray(image_data)

    if remove_channel not in ['b', 'g', 'r']:
        print("Error! Invalid choice.")
        return

    if bpp <= 8:
        print("Image is {} bits per pixel".format(bpp))
        if remove_channel == 'b':
            for i in range(54, offset, 4):
                mylist[i] = 0
        elif remove_channel == 'g':
            for i in range(54, offset, 4):
                mylist[i + 1] = 0
        elif remove_channel == 'r':
            for i in range(54, offset, 4):
                mylist[i + 2] = 0
        else:
            print("Error! Invalid choice.")
    elif bpp == 24:
        print("Image is {} bits per pixel".format(bpp))
        if remove_channel == 'b':
            for i in range(offset, len(mylist), 3):
                mylist[i] = 0
        elif remove_channel == 'g':
            for i in range(offset, len(mylist), 3):
                mylist[i + 1] = 0
        elif remove_channel == 'r':
            for i in range(offset, len(mylist), 3):
                mylist[i + 2] = 0
        else:
            print("Error! Invalid choice.")
    else:
        print("Unsupported bpp: {}".format(bpp))
        return

    new_image_data = bytes(mylist)
    write_new_bmp(new_image_data, file_name)

def write_new_bmp(data, file_name):
    with open(file_name, 'wb') as new_file:
        new_file.write(data)


remove_channel = input("Enter the channel you wish to make zero (b, g, r): ").lower()

# Read the BMP header
file_path = "/content/corn.bmp"
file_name = "output_without_" + remove_channel + ".bmp"
header_info = read_bmp_header(file_path)

if header_info is not None:
    with open(file_path, 'rb') as file:
        # Read the entire image data
        image_data = file.read()

color_channel_manipulation(image_data, file_name)
display_img(file_name)